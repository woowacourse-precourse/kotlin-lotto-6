# 🎰 로또 게임

**로또 게임**은 사용자에게 로또 번호를 발행하고, 사용자가 입력한 로또 번호와 당첨 번호를 비교하여 당첨 내역과 수익률을 계산하는 프로젝트입니다. <br/>
이 프로젝트는 로또 게임을 시뮬레이션하고, 사용자에게 로또를 구매할 기회를 제공하며, 당첨 번호와 비교하여 당첨 결과 및 수익률을 확인할 수 있는 기능을 포함하고 있습니다.

## 💡 구현할 기능 목록

1. **게임 시작을 알리는 문구 출력**
    - "로또 게임을 시작합니다."
2. **로또 구입**
    - "구입금액을 입력해 주세요. (1,000원 단위로 입력)" 출력
    - 1,000원으로 나누어 떨어지지 않는 경우 예외 처리
    - 사용자로부터 구입 금액 입력받기
3. **로또 번호 발행**
    - 구매한 로또 수량에 맞게 로또 번호 생성
4. **로또 번호 출력**
   - "n개를 구매했습니다." 출력
   - 발행된 로또 번호를 출력
   - 로또 번호는 오름차순으로 정렬
5. **당첨 번호 및 보너스 번호 입력**
    - "당첨 번호를 입력해 주세요. (1~45까지 중복되지 않는 6개의 번호, 쉼표(,)로 구분)" 출력
    - 사용자로부터 당첨 번호 6개 입력받기
    - "보너스 번호를 입력해 주세요. (1~45까지 중복되지 않는 번호)" 출력
    - 보너스 번호 입력받기
6. **당첨 통계 확인 및 출력**
    - 사용자가 구매한 로또 번호와 당첨 번호를 비교하여 당첨 내역 및 수익률 출력
    - 수익률은 소수점 둘째 자리에서 반올림 (ex. 230.7%, 51.5%)
7. **예외 처리**
    - 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시켜 "[ERROR]"로 시작하는 에러 메시지 출력
    - 출력 후 그 부분부터 재입력 받기
8. **indent(들여쓰기) depth 관리**
    - 함수(또는 메서드)가 3 이상의 들여쓰기 depth를 가지지 않도록 구현
9. **함수(또는 메서드) 분리**
    - 함수(또는 메서드)가 한 가지 일만 하도록 작게 만들어 코드 가독성을 높임
10. **테스트 코드 작성**
    - JUnit 5와 AssertJ를 사용하여 구현한 기능이 정상 동작하는지 확인하는 테스트 코드 작성

<br/>

## 🤔 테스트 코드를 작성하는 이유

제가 생각했을 때 테스트 코드를 작성하는 이유는 다음과 같습니다.

**안정성 측면**
- 테스트 코드를 작성하여 동작을 검증함으로써 휴먼에러와 같은 버그, 오류 등을 사전에 예방할 수 있습니다.
- 또한 추가적인 변경사항이 생겼을 경우에도 충돌을 즉시 확인할 수 있다는 장점이 있습니다.

**온보딩 측면**
- 테스트 코드를 작성하면 온보딩 측면에서도 큰 장점이 있습니다.
- 새로운 개발자가 투입되었을 시 테스트 코드를 통해 코드의 동작을 빠르게 확인이 가능합니다.
- 이는 테스트 코드는 작성한 의도와 예상 동작등이 명시되어 있기 때문에 이를 통해 코드의 이해도가 올라가기 때문입니다.

**리팩토링 측면**
- 리팩토링을 할 경우 테스트 코드가 있다면 지속적으로 동작을 확인하며 할 수 있기 때문에 문제 발생 시 즉시 확인할 수 있습니다.
- 이는 리팩토링 후 검증의 측면에서도 쓰일 수 있습니다.

**생산성 향상 측면**
- 초기에 작성시에는 시간이 걸릴 수 있지만 작성 이후엔 버그를 빠르게 발견할 수 있습니다.
- 이로 인해 전체적인 개발 소요시간이 단축됩니다.
- 코드의 일부분을 손쉽게 테스트 가능하며 자동적으로 검증이 되기 때문에 테스트 시간이 절약됩니다.

**협업 측면**
- 제가 가장 중요하게 생각하는 요소 중 하나입니다.
- 위에서 설명했던 장점들도 모두 중요합니다. 하지만 위에서 말했던 장점 모두 협업 측면에서의 장점과 동일합니다.
- 테스트 코드는 여러 개발자가 협업을 진행할 때 신뢰성, 이해도, 온보딩, 리팩토링, 생산성 등 다양한 측면에서의 장점이 있습니다.
- 이는 결과적으로 개발시간 단축, 개발에 대한 몰입 증가 등 큰 장점으로 이어집니다.

위의 5가지가 제가 가장 중요하게 생각하는 생각하는 테스트 코드를 작성하는 이유입니다.


<br/>

## ⚙️ Architecture/Design Pattern

### MVVM

**View와 Model 사이의 의존성을 낮춰주는 패턴으로 온보딩, 확장성, 유지보수성, 테스트 용이성 등 다양한 이점이 있는 MVVM 패턴 채택**

<br/>

## 📑 File Structure

##### dataLayer

- Model
  - LottoWinningnumber
  - UserLottoState

- repository
  - LottoRepositoryImpl : 로또 게임 데이터를 관리하는 repository 구현부 클래스

##### uiLayer

- repository
  - LottoRepository : Facade 패턴을 사용해 view에게 단순한 인터페이스를 제공하는 repository interface
- viewModel
  - LottoViewModel : 로또 게임과 관련된 비즈니스 로직을 처리하는 ViewModel 클래스 -> 게임 로직과 UI를 분리하여 유지보수성, 확장성, 테스트 용이성 등을 높임
- Lotto : 사용자와 상호작용하며 레이싱 게임의 플로우를 제어하는 View의 역할을 하는 클래스 -> 당첨 번호와 구매한 로또를 비교한 최종 통계를 ViewModel에 요청해 출력해주는 클래스
- LottoGame : 사용자와 상호작용하며 레이싱 게임의 플로우를 제어하는 View의 역할을 하는 클래스 -> 사용자에게 로또 번호, 구매금액 등을 입력받아 viewModel을 통해 데이터를 요청하는 클래스

##### utils
- CommonConst : 게임에서 사용되는 공통 문자열 상수를 정의한 클래스로, 화면에 표시되는 메시지나 문자열 값들을 관리
- Exceptions : 예외 처리를 담당하는 클래스로, 잘못된 입력이나 예외 상황을 처리하기 위한 함수들을 제공
- GameUtils : 게임에서 사용되는 유틸리티 함수들을 제공하는 객체
- PrizeType : 로또 게임에서 각 등수에 해당하는 상금을 정의하고 관리하는 클래스로 등수와 상금을 간단하게 매핑하여 관리할 수 있도록 구현

<br/>

## 📌 Convention

### Commit Message Convention

| Tag          | Description                   |
|--------------|-------------------------------|
| [Feat] :     | 새로운 기능을 추가                    |
| [Fix] :      | 버그 수정                         |
| [Docs] :     | 문서 수정, 필요한 주석 추가 및 변경         |
| [Test] :     | 테스트 코드, 리팩토링 테스트 코드 추가        |
| [Refactor] : | 코드 구조 변경 등 리팩토링               |
| [Rename] :   | 파일 또는 폴더 명을 수정하거나 옮기는 작업만인 경우 |
| [Remove] :   | 파일을 삭제하는 작업만 수행한 경우           |
| [Const] :    | 상수 추가 또는 변경                   |

- 제목과 본문을 빈행으로 분리
- 여러가지 항목이 있다면 글머리 기호를 통해 가독성 높이기
- 자신의 코드가 직관적으로 바로 파악할 수 있다고 생각하지 않기

### Coding Convention

**❝**  **문자열을 처리할 때는 쌍따옴표를 사용하도록 합니다.**

🐫 **함수명, 변수명은 카멜케이스로 작성합니다. (camelCase)**

🤙 **변수 이름에 자료형은 사용하지 않습니다.**

- 변수 이름에 자료형, 자료 구조 등을 사용하지 않는다.

☝ **한 함수가 한 가지 기능만 담당하게 합니다.**

- 함수 길이가 길어진다면 한 함수에서 여러 일을 하려고 하는 경우일 가능성이 높다.
- 아래와 같이 한 함수에서 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.

```kotlin
fun userInput(): List<String> {
    println("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분)")
    val userInput = Console.readLine().trim()
    val splittedName = userInput.split(",")
    splittedName.forEach {
        require(user.length <= 5) { "[ERROR] 자동차 이름은 1자 이상 5자 이하만 가능합니다." }
    }
    return splittedName
}
```

☝ **가독성을 위해 한 줄에 하나의 문장만 작성합니다.**

🤙 **코드 구현 완료 후 정렬을 해줍니다. (`ctrl` + `Alt` + `L`), (`command` + `option` + `L`)**

🐈 **의미 없는 주석을 달지 않습니다.**

- 변수 이름, 함수(메서드) 이름을 통해 어떤 의도인지가 드러난다면 굳이 주석을 달지 않는다.
- 모든 변수와 함수에 주석을 달기보다 가능하면 이름을 통해 의도를 드러내고, 의도를 드러내기 힘든 경우 주석을 다는 연습을 한다.

☝ **값을 하드 코딩하지 않습니다.**

- 문자열, 숫자 등의 값을 하드 코딩하지 않는다.
- 상수를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러낸다.
- 구글에서 "kotlin 상수"와 같은 키워드로 검색해 상수 구현 방법을 학습하고 적용해 본다.

☝ **구현 순서를 지킵니다.**

- 클래스는 프로퍼티, init 블록, 부 생성자, 메서드, 동반 객체 순으로 작성한다.

```kotlin
class A {
    프로퍼티

    init 블록

    부 생성자

    메서드

    동반 객체
}
```

☝ **연산자 사이에는 공백을 추가하여 가독성을 높입니다.**

```kotlin
a + b + c + d // bad
a + b + c + d // good
```

☝ **콤마 다음에 값이 올 경우 공백을 추가하여 가독성을 높입니다.**

```kotlin
var arr = [1, 2, 3, 4] //bad
var arr = [1, 2, 3, 4] //good
```


